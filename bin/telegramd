#!/usr/bin/perl

use strict;
use warnings;
use utf8;

use Clib::Proc qw|script1 lib|;
use Clib::Const ':utf8';
use Clib::Log 'log_telegramd';

use Clib::DT;
use RedisDB;
use Encode;

use WWW::Telegram::BotAPI;

$SIG{__DIE__} = sub { error('DIE: %s', $_) for @_ };

# наш токен
my $token = c('telegram_token');
if (!$token) {
    error('`telegram_token` not defined');
    exit -1;
}

# можно уходить в фон
Clib::Proc::daemon(
    pidfile => (c('pidPath')||'.').'/telegramd.pid',
    procname => 'Manifest-Telegram-Bot',
    no => c('telegramd_nodaemon'),
) || exit -1;

my $api = WWW::Telegram::BotAPI->new(token => $token) || exit -1;
my $isreq;
Clib::Proc::sigint(sub { 
    log('Interrupted');
    if ($api) {
        undef $api;
    }
    if ($isreq) {
        # Костыль для выхода из запроса.
        die 'Terminate';
    }
});

# Подключаемся к API и проверяем авторизацию
my $me;
while ($api) {
    $me = request('getMe');
    $me || exit -1;
    
    last if $me->{ok} && $me->{result} && $me->{result}->{id};

    # Запуститься процесс может, когда у нас нет соединения с интернет,
    # поэтому не выходим, а ждём, когда появятся данные
    # с интервалом 5-10 минут
    error('Not valid token or Telegram-API fail: %s', $me->{error});
    sleep 300;
}

# скидываем все уже имеющиеся сообщения
my @off = ();
if ($api) {
    my $upd = request('getUpdates');
    if (!$upd->{ok} || !$upd->{result}) {
        error('Can\'t getUpdates on init: %s', $me->{error});
        exit -1;
    }
    foreach my $u (@{ $upd->{result} }) {
        @off = (offset => $u->{update_id}+1);
        my $msg = $u->{message} || next;
        debug('Skip msg[%d] on %s from %s: %s', 
            $msg->{message_id}, Clib::DT::datetime($msg->{date}), 
            $msg->{from}->{first_name} || '['.$msg->{from}->{id}.']',
            $msg->{text});
    }
}

log('Starting with %s', $me && $me->{result} ? $me->{result}->{first_name}||$me->{result}->{username} : '-unknown-');

# основной цикл
while ($api) {
    #debug(join ': ', @off, $api);
    my $upd = request(getUpdates => @off, timeout => 5 );
    if (!$upd->{ok} || !$upd->{result}) {
        error('getUpdates fail: %s', $upd->{error});
        $api || last;
        sleep 60;
        next;
    }
    foreach my $u (@{ $upd->{result} }) {
        @off = (offset => $u->{update_id}+1);
        my $msg = $u->{message} || next;
        log('Message[%d] on %s from %s: %s',
            $msg->{message_id}, Clib::DT::datetime($msg->{date}), 
            $msg->{from}->{first_name} || '['.$msg->{from}->{id}.']',
            $msg->{text});
        my $chat = $msg->{chat} || next;
        
        if ($msg->{text} =~ /^(?:я|im?)(\s+(.+))?$/i) {
            cmd_im($chat, $1);
        }
        elsif ($msg->{text} =~ /^(?:уд(алить)?|unreg|del(ete)?)/i) {
            cmd_unreg($chat);
        }
    }
}

log('Finished');

# Запрос в API Telegram
sub request {
    my $method = shift();
    if (!$api) {
        error('api not inited');
        return;
    }
    local $SIG{__DIE__} = undef;
    $isreq = 1;
    my $r = eval { $api->api_request($method, @_ ? { @_ } : ()) };
    undef $isreq;
    if (!$r && $@) {
        $r = { error => $@ };
    }
    return $r || { error => 'Unknown error' };
}

# Ответ в чат с пользователем
sub reply {
    my $chatid = shift();
    
    my $msg = shift();
    if (my $s = c(telegram_reply => $msg)) {
        $msg = $s;
    }
    
    $msg = sprintf($msg, @_) if @_;
    
    my $r = request(sendMessage => 
        chat_id => $chatid,
        text    => $msg,
    );
    
    error('Can\'t reply to chatid=%d: %s', $chatid, $r->{error})
        if $r && $r->{error};
    
    return $r && $r->{result} ? 1 : 0;
}

# Соединение с Redis
my $redis;
sub redis {
    my $chatid = shift;
    
    $redis ||= RedisDB->new(
                raise_error => 0,
                lazy => 1,
                
                %{ c('redis')||{} },
            );
    
    if (!$redis) {
        reply($chatid, 'db') if $chatid;
        return;
    }
    
    @_ || return 1;
    
    my $command = shift;
    my @uccom = split /_/, uc $command;
    
    my $ret = $redis->execute(@uccom, @_);
    
    if (ref($ret) =~ /RedisDB\:\:Error/) {
        error('[Redis ERROR] : %s', $ret->as_string);
        reply($chatid, 'db') if $chatid;
        return;
    }
    elsif (!$ret && $@) {
        error('[Redis EXCEPTION] : %s', $@);
        reply($chatid, 'db') if $chatid;
        return;
    }
    
    if (defined($ret) && !ref($ret)) {
        Encode::_utf8_on($ret);
    }
    
    return $ret;
}

##==========================================================
##==========================================================
##==========================================================

sub cmd_im {
    my ($chat, $name) = @_;
    
    my @name;
    if (!defined($name) ||
        !(@name = ($name =~ /^\s*(([a-zA-Zа-яА-Я]+)(?:\s*([a-zA-Zа-яА-Я]\.(?:[a-zA-Zа-яА-Я]\.)?))?)\s*$/))) {
        reply($chat->{id}, 'im_format');
        return;
    }
    
    my ($full, $fam, $io) = @name;
    
    #my $code = lc $full;
    #$code =~ s/\s//g;
    
    my $regexp = $fam;
    if ($io) {
        $io =~ s/\./\\\./g;
        $regexp .= '\s*' . $io;
    }
    
    if (redis($chat->{id}, hexists => uname  => $chat->{id})) {
        cmd_unreg($chat) || return;
    }
    
    redis($chat->{id}, hset => uname  => $chat->{id} => $full) || return;
    redis($chat->{id}, hset => uregexp=> $chat->{id} => $regexp) || return;
    
    reply($chat->{id}, 'im_ok', $name[0]);
    
    1;
}

sub cmd_unreg {
    my ($chat) = @_;
    
    my $name = redis($chat->{id}, hget => uname  => $chat->{id});
    
    if (!defined($name)) {
        reply($chat->{id}, 'unreg_noexists');
        return;
    }
    
    redis($chat->{id}, hdel => uregexp=> $chat->{id}) || return;
    redis($chat->{id}, hdel => uname  => $chat->{id}) || return;
    
    reply($chat->{id}, 'unreg_ok', $name);
    
    1;
}

##==========================================================
#================================================== End ===
#==========================================================
